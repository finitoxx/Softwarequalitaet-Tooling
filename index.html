<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Softwarequalitäts-Tooling
---
# Gliederung

---
class: center, middle

# Tests für funktionales Javascript

---
# Warum Tests?

- Man testet, um sicherzugehen, dass die Anwendung das macht, was sie tun soll
- Man kann seinen Code besser refactoren, da die Tests die Funktionalität prüfen
- Es gibt 3 Arten von Tests: __Unit-Tests__, __Integrations-Tests__, __Funktionalitäts-Tests__
- Tests können an verschiedenen Stellen im Codierungsprozess geschrieben werden
- TDD(Test-Driven-Development) bietet sich an, da man hier auch gut die Andorderungen in die Tests integrieren kann

---
# Warum Funktionale Tests?

- Mit funktionalem Programmieren lassen sich leichter Tests schreiben (Funktionale Tests)
- Programme die eng miteinander verkettet sind und viel auf globale Variablen arbeiten sind sehr schwer zu testen
- Pure Functions  sind leicht austauschbar,wiederverwendbar und eignene sich sehr gut für funktionale Tests
- -> Sie sind nicht abhängig von externen Verhalten oder Variablen
- -> Sie verursachen keine Nebeneffekte oder verändern externe Variablen
- -> Sie geben immer das selbe Resultat bei gleichem Input aus
---
# Jasmine
Einbinden mit:
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Jasmine Test</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.6.1/jasmine.min.css">
  </head>
  <body>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.6.1/jasmine.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.6.1/jasmine-html.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.6.1/boot.min.js"></script>
  </body>
</html>
```
Dies bindet uns die Jasmine-Bibliothek sowie das Jasmine HTML-Bootskript und Styling ein.
---
# Der erste Test
- Test wird definiert bevor die Funktion geschrieben wird(->TDD)
```javascript
describe("isPalindrome", () => {
  it("returns true if the string is a palindrome", () => {
    expect(isPalindrome("abba")).toEqual(true);
  });
});
```
Wenn die Seite geladen wird, wird die Jasmine Report Seite angezeigt
---
# Erfüllen des ersten Tests
- Wir fügen nun einfach folgende Funktion ein:
```javascript
const isPalindrome = (str) => {
  return str
    .split("")
    .reverse()
    .join("") === str;
};
```
Der Test wird nun erfüllt! Jetzt kann man noch weitere Spezifikationen hinzufügen und die Implementation weiter anpassen. Der Test wird dann immer die Grundfunktionalität überprüfen.

- Man kann nun die Tests erweitern und dann mithilfe von Refactoring die Tests wieder erfüllen!
- Dies sorgt für eine saubere und ordentliche Programmierweise
---
class: center, middle

# Mocha-Chai und Sinonjs

---
class: center, middle

# Jest




    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>